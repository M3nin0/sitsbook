<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Object-based time series image analysis | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes</title>
<meta name="author" content="Gilberto Camara">
<meta name="author" content="Rolf Simoes">
<meta name="author" content="Felipe Souza">
<meta name="author" content="Charlotte Pelletier">
<meta name="author" content="Alber Sanchez">
<meta name="author" content="Pedro R. Andrade">
<meta name="author" content="Karine Ferreira">
<meta name="author" content="Gilberto Queiroz">
<meta name="description" content="Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into meaningful segments or objects, which are then classified and analyzed. In contrast...">
<meta name="generator" content="bookdown 0.33 with bs4_book()">
<meta property="og:title" content="Object-based time series image analysis | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes">
<meta property="og:type" content="book">
<meta property="og:image" content="/images/cover_sits_book.png">
<meta property="og:description" content="Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into meaningful segments or objects, which are then classified and analyzed. In contrast...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Object-based time series image analysis | sits: Satellite Image Time Series Analysis on Earth Observation Data Cubes">
<meta name="twitter:description" content="Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into meaningful segments or objects, which are then classified and analyzed. In contrast...">
<meta name="twitter:image" content="/images/cover_sits_book.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/IBM_Plex_Serif-0.4.6/font.css" rel="stylesheet">
<link href="libs/IBM_Plex_Mono-0.4.6/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.4.2/transition.js"></script><script src="libs/bs3compat-0.4.2/tabs.js"></script><script src="libs/bs3compat-0.4.2/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title=""><strong>sits</strong>: Satellite Image Time Series Analysis on Earth Observation Data Cubes</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Preface</a></li>
<li><a class="" href="setup.html">Setup</a></li>
<li><a class="" href="acknowledgements.html">Acknowledgements</a></li>
<li><a class="" href="introduction.html">Introduction</a></li>
<li><a class="" href="earth-observation-data-cubes.html">Earth observation data cubes</a></li>
<li><a class="" href="operations-on-data-cubes.html">Operations on data cubes</a></li>
<li><a class="" href="working-with-time-series.html">Working with time series</a></li>
<li><a class="" href="improving-the-quality-of-training-samples.html">Improving the quality of training samples</a></li>
<li><a class="" href="machine-learning-for-data-cubes.html">Machine learning for data cubes</a></li>
<li><a class="" href="image-classification-in-data-cubes.html">Image classification in data cubes</a></li>
<li><a class="" href="bayesian-smoothing-for-post-processing.html">Bayesian smoothing for post-processing</a></li>
<li><a class="" href="validation-and-accuracy-measurements.html">Validation and accuracy measurements</a></li>
<li><a class="" href="uncertainty-and-active-learning.html">Uncertainty and active learning</a></li>
<li><a class="" href="ensemble-prediction-from-multiple-models.html">Ensemble prediction from multiple models</a></li>
<li><a class="active" href="object-based-time-series-image-analysis.html">Object-based time series image analysis</a></li>
<li><a class="" href="technical-annex.html">Technical Annex</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="object-based-time-series-image-analysis" class="section level1 unnumbered">
<h1>Object-based time series image analysis<a class="anchor" aria-label="anchor" href="#object-based-time-series-image-analysis"><i class="fas fa-link"></i></a>
</h1>
<p>Object-Based Image Analysis (OBIA) is an approach to remote sensing image analysis that partitions an image into meaningful segments or objects, which are then classified and analyzed. In contrast to traditional pixel-based approaches, which analyze each individual pixel in isolation, OBIA operates on groups of pixels, or “segments”, which have similar spectral and spatial characteristics.</p>
<p>The general sequence of the processes involved in OBIA include:</p>
<ol style="list-style-type: decimal">
<li><p>Segmentation: The first step in OBIA is to group together pixels that are similar based on certain criteria such as color, intensity or texture. These groupings are called “segments”. The aim here is to create objects that represent meaningful features in the real world, like buildings, roads, fields, forests, and water bodies.</p></li>
<li><p>Attribute Calculation: After the image has been segmented into distinct objects, the next step is to extract attributes from each object. In general, these attributes can be spectral (e.g., mean reflectance), spatial (e.g., size, shape, orientation), or textural (e.g., smoothness, roughness).</p></li>
<li><p>Classification: Once the attributes have been extracted from the segments, they can be used to classify each segment.</p></li>
</ol>
<p>One of the advantages of OBIA is that it more closely mimics the way humans visually perceive their environment, not by individual pixels, but by groups of pixels as meaningful objects. This often results in more accurate and contextually rich analysis of imagery data. It’s widely used in various fields such as environmental monitoring, agriculture, urban planning, defense, and more.</p>
<p>Version 1.4.1. of <code>sits</code> includes an extension of OBIA for working with image time series. The initial step of the process is to segment one image of a reference date. Then, for each segment, we use an aggregation function to obtain a set of spectral attributes for each segment. The default option is to take the mean value for each temporal instance of each band. The result are a set of time series, one for each segment. Each time series is then classified independently. The result can be joined together with the original image to obtain a classification. We call this process “OBIA-TS” (object-based image time series analysis)</p>
<div id="generic-image-segmentation-in-sits" class="section level2 unnumbered">
<h2>Generic Image segmentation in SITS<a class="anchor" aria-label="anchor" href="#generic-image-segmentation-in-sits"><i class="fas fa-link"></i></a>
</h2>
<p>The first step of the OBIA-TS procedure is to select a data cube to be segmented and function that performs the segmentation. For this purpose, <code>sits</code> provides a generic <code><a href="https://rdrr.io/pkg/sits/man/sits_segment.html">sits_segment()</a></code> function, which allows users to select different segmentation algorithms. The <code><a href="https://rdrr.io/pkg/sits/man/sits_segment.html">sits_segment()</a></code> function has the following parameters:</p>
<ul>
<li>
<code>cube</code>: a regular data cube.</li>
<li>
<code>tiles</code>: tiles to be segmented.</li>
<li>
<code>bands</code>: bands to include in the segmentation</li>
<li>
<code>dates</code>: dates to include in the segmentation</li>
<li>
<code>seg_fn</code>: function to apply the segmentation</li>
<li>
<code>...</code>: other params to be passed to segmentation function</li>
</ul>
<p>In <code>sits</code> version 1.4.2, there is only one segmentation function available that implements the Simple Linear Iterative Clustering (SLIC) algorithm, which is described below. In future versions of <code>sits</code>, we expect to include additional functions that support spatio-temporal segmentation.</p>
</div>
<div id="simple-linear-iterative-clustering-slic-algorithm" class="section level2 unnumbered">
<h2>Simple Linear Iterative Clustering (SLIC) algorithm<a class="anchor" aria-label="anchor" href="#simple-linear-iterative-clustering-slic-algorithm"><i class="fas fa-link"></i></a>
</h2>
<p>In <code>sits</code> 1.4.2, we provide an implementation of The Simple Linear Iterative Clustering (SLIC) algorithm <span class="citation"><a href="references.html#ref-Achanta2012a">[90]</a></span>. SLIC uses spectral similarity and proximity in the image space to segment the image into “superpixels”. Superpixels are clusters of pixels with similar spectral responses that are close together, which correspond to coherent object parts in the image. Here’s a high-level view of the SLIC algorithm:</p>
<ol style="list-style-type: decimal">
<li><p>The algorithm starts by dividing the image into a grid, where each cell of the grid will become a superpixel.</p></li>
<li><p>For each cell, the pixel in the center becomes the initial “cluster center” for that superpixel.</p></li>
<li><p>For each pixel, the algorithm calculates a distance to each of the nearby cluster centers. This distance includes both a spatial component (how far the pixel is from the center of the superpixel in terms of x and y coordinates) and a spectral component (how different the pixel’s spectral values are from the average values of the superpixel).</p></li>
<li><p>Each pixel is assigned to the closest cluster. After all pixels have been assigned to clusters, the algorithm recalculates the cluster centers by averaging the spatial coordinates and spectral values of all pixels within each cluster.</p></li>
<li><p>Steps 3-4 are repeated for a set number of iterations, or until the cluster assignments stop changing.</p></li>
</ol>
<p>The outcome of the SLIC algorithm is a set of superpixels which try to capture the to boundaries of objects within the image. The SLIC implementation in <code>sits</code> 1.4.1 uses the <code>supercells</code> R package <span class="citation"><a href="references.html#ref-Nowosad2022">[91]</a></span>. The parameters for the <code><a href="https://rdrr.io/pkg/sits/man/sits_supercells.html">sits_supercells()</a></code> function are:</p>
<ul>
<li>
<code>dist_fn</code>: metric used to calculate the distance between values. By default, the “euclidean” metric is used. Alternatives include “jsd” (Jensen-Shannon distance), and “dtw” (dynamic time warping) or one of 46 distance and similarity measures implemented in the R package <code>philentropy</code> <span class="citation"><a href="references.html#ref-Drost2018">[92]</a></span>.</li>
<li>
<code>avg_fn</code>: function to calculate a value of each superpixel. There are two internal functions implemented in C++ - “mean” and “median”. It is also possible to provide a user-defined R function that returns one value based on an R vector.</li>
<li>
<code>step</code>: distance, measured in the number of cells, between initial superpixels’ centers.</li>
<li>
<code>compactness</code>: A value that controls superpixels’ density. Larger values cause clusters to be more compact.</li>
<li>
<code>minarea</code>: minimal size of the output superpixels (measured in number of cells).</li>
</ul>
</div>
<div id="example-of-slic-based-segmentation-and-classification" class="section level2 unnumbered">
<h2>Example of SLIC-based segmentation and classification<a class="anchor" aria-label="anchor" href="#example-of-slic-based-segmentation-and-classification"><i class="fas fa-link"></i></a>
</h2>
<p>To show an example of SLIC-based segmentation, we first build a data cube, using images available in the <code>sitsdata</code> package.</p>
<div class="sourceCode" id="cb166"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># directory where files are located</span></span>
<span><span class="va">data_dir</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"extdata/Rondonia-20LKP"</span>, package <span class="op">=</span> <span class="st">"sitsdata"</span><span class="op">)</span></span>
<span><span class="co"># Builds a cube based on existing files</span></span>
<span><span class="va">s2_cube</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_cube.html">sits_cube</a></span><span class="op">(</span></span>
<span>  source <span class="op">=</span> <span class="st">"AWS"</span>,</span>
<span>  collection <span class="op">=</span> <span class="st">"SENTINEL-2-L2A"</span>,</span>
<span>  data_dir <span class="op">=</span> <span class="va">data_dir</span>,</span>
<span>  parse_info <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"X1"</span>, <span class="st">"tile"</span>, <span class="st">"band"</span>, <span class="st">"date"</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">s2_cube</span>, red <span class="op">=</span> <span class="st">"B11"</span>, green <span class="op">=</span> <span class="st">"B8A"</span>, blue <span class="op">=</span> <span class="st">"B02"</span>, date <span class="op">=</span> <span class="st">"2020-09-24"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:unnamed-chunk-162"></span>
<img src="sitsbook_files/figure-html/unnamed-chunk-162-1.png" alt="Sentinel-2 image in an area of Rondonia in Brazil" width="100%"><p class="caption">
Figure 90: Sentinel-2 image in an area of Rondonia in Brazil
</p>
</div>
<p>Given that the SLIC algorithm uses a single date and that the date of “2020-09-04” is cloud-free and is close to the end of the dry season in Amazonia, it is selected as a suitable date for the segmentation.</p>
<p>The following example produces a segmented image.</p>
<div class="sourceCode" id="cb167"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># segment a cube using</span></span>
<span><span class="va">segments_20LKP</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_segment.html">sits_segment</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">s2_cube</span>,</span>
<span>  tiles <span class="op">=</span> <span class="st">"20LKP"</span>,</span>
<span>  bands <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"B02"</span>, <span class="st">"B11"</span>, <span class="st">"B8A"</span><span class="op">)</span>,</span>
<span>  dates <span class="op">=</span> <span class="st">"2020-09-24"</span>,</span>
<span>  seg_fn <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_supercells.html">sits_supercells</a></span><span class="op">(</span></span>
<span>    step <span class="op">=</span> <span class="fl">60</span>,</span>
<span>    compactness <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    dist_fun <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>    iter <span class="op">=</span> <span class="fl">10</span>,</span>
<span>    minarea <span class="op">=</span> <span class="fl">50</span>,</span>
<span>    multicores <span class="op">=</span> <span class="fl">1</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>It is useful to visualize the segments together with the RGB image using <code><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view()</a></code>.</p>
<div class="sourceCode" id="cb168"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view</a></span><span class="op">(</span><span class="va">s2_cube</span>,</span>
<span>  red <span class="op">=</span> <span class="st">"B11"</span>, green <span class="op">=</span> <span class="st">"B8A"</span>, blue <span class="op">=</span> <span class="st">"B02"</span>,</span>
<span>  date <span class="op">=</span> <span class="st">"2020-09-24"</span>, segments <span class="op">=</span> <span class="va">segments_20LKP</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/view_segments_RGB_detail.png" width="90%" style="display: block; margin: auto;"></div>
<p>After obtaining the segments, the next step is to obtain one time series per segment. Each time series will represent one entire object and will be classified independently. To do this, use <code><a href="https://rdrr.io/pkg/sits/man/sits_get_data.html">sits_get_data()</a></code> passing the segments as the samples. See Chapter “Working with time series” for a detailed description of <code><a href="https://rdrr.io/pkg/sits/man/sits_get_data.html">sits_get_data()</a></code>.</p>
<div class="sourceCode" id="cb169"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">time_series_segments</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_get_data.html">sits_get_data</a></span><span class="op">(</span></span>
<span>  cube <span class="op">=</span> <span class="va">s2_cube</span>,</span>
<span>  samples <span class="op">=</span> <span class="va">segments_20LKP</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># show the output</span></span>
<span><span class="va">time_series_segments</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="op">]</span></span></code></pre></div>
<pre class="sourceCode"><code>#&gt; # A tibble: 4 × 9
#&gt;   longitude latitude start_date end_date   label   cube         tile  polygon_id
#&gt;       &lt;dbl&gt;    &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt;
#&gt; 1     -65.2    -10.7 2020-06-04 2021-08-26 NoClass SENTINEL-2-… 20LKP         25
#&gt; 2     -65.2    -10.7 2020-06-04 2021-08-26 NoClass SENTINEL-2-… 20LKP         21
#&gt; 3     -65.2    -10.6 2020-06-04 2021-08-26 NoClass SENTINEL-2-… 20LKP          6
#&gt; 4     -65.2    -10.6 2020-06-04 2021-08-26 NoClass SENTINEL-2-… 20LKP          8
#&gt; # ℹ 1 more variable: time_series &lt;list&gt;</code></pre>
<p>The <code>time_series_segments</code> object is a standard <code>sits</code> time series. For each segment, it contains the latitude/longitude of its geometrical centroid, the start and end dates of the cube. Its time series values will be computed as the average of all pixels inside the segment.</p>
<p>After obtaining the segments, the next step is building the machine learning model. This model will use training samples selected by INPE’s researchers that describe the various land classes in the state of Rondonia; these samples are available in package <code>sitsdata</code>.</p>
<div class="sourceCode" id="cb171"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">samples_file</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"extdata/Rondonia-model/samples.rds"</span>, package <span class="op">=</span> <span class="st">"sitsdata"</span><span class="op">)</span></span>
<span><span class="va">samples</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/readRDS.html">readRDS</a></span><span class="op">(</span><span class="va">samples_file</span><span class="op">)</span></span>
<span><span class="co"># select the bands to match those of the data cube</span></span>
<span><span class="va">samples_3bands</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_select.html">sits_select</a></span><span class="op">(</span><span class="va">samples</span>, bands <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"B02"</span>, <span class="st">"B11"</span>, <span class="st">"B8A"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Using the samples, we can now obtain a machine learning model and apply it to classify the time series associated to the segments.</p>
<div class="sourceCode" id="cb172"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Obtain a random forest model</span></span>
<span><span class="va">rf_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_train.html">sits_train</a></span><span class="op">(</span><span class="va">samples_3bands</span>, <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_rfor.html">sits_rfor</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># classify the time series segments</span></span>
<span><span class="va">time_series_class</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_classify.html">sits_classify</a></span><span class="op">(</span></span>
<span>  data <span class="op">=</span> <span class="va">time_series_segments</span>,</span>
<span>  ml_model <span class="op">=</span> <span class="va">rf_model</span>,</span>
<span>  multicores <span class="op">=</span> <span class="fl">4</span></span>
<span><span class="op">)</span></span>
<span><span class="co">### show the first time series segments classified</span></span>
<span><span class="va">time_series_class</span><span class="op">$</span><span class="va">predicted</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre class="sourceCode"><code>#&gt; # A tibble: 1 × 10
#&gt;   from       to         class     Bare_Soil ClearCut_BareSoil ClearCut_Burn
#&gt;   &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;         &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;
#&gt; 1 2020-06-04 2021-08-26 Bare_Soil       0.8               0.2             0
#&gt; # ℹ 4 more variables: ClearCut_Veg &lt;dbl&gt;, Forest &lt;dbl&gt;, Water &lt;dbl&gt;,
#&gt; #   Wetlands &lt;dbl&gt;</code></pre>
<p>The result of the classification is time series tibble, with an additional column called “predicted” that contains the most likely class for each pixel (in this case “Forest”), with the probabilities associated to each class. After obtaining the classes for the centroids of each object, it is useful to join the resulting time series tibble with the original segments using <code><a href="https://rdrr.io/pkg/sits/man/sits_join_segments.html">sits_join_segments()</a></code>. The result of this function is a set of labelled segments, which can be used by other R applications such as <code>sf</code> and can also be viewed in <code>sits</code>.</p>
<div class="sourceCode" id="cb174"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">labelled_segments</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_join_segments.html">sits_join_segments</a></span><span class="op">(</span></span>
<span>  data <span class="op">=</span> <span class="va">time_series_class</span>,</span>
<span>  segments <span class="op">=</span> <span class="va">segments_20LKP</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>To view the classified segments together with the original image, use <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code> or <code><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view()</a></code>, as in the following example.</p>
<div class="sourceCode" id="cb175"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/sits/man/sits_view.html">sits_view</a></span><span class="op">(</span></span>
<span>  <span class="va">s2_cube</span>,</span>
<span>  red <span class="op">=</span> <span class="st">"B11"</span>,</span>
<span>  green <span class="op">=</span> <span class="st">"B8A"</span>,</span>
<span>  blue <span class="op">=</span> <span class="st">"B02"</span>,</span>
<span>  dates <span class="op">=</span> <span class="st">"2020-09-24"</span>,</span>
<span>  segments <span class="op">=</span> <span class="va">labelled_segments</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="images/view_segments_class.png" width="90%" style="display: block; margin: auto;"></div>

</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="ensemble-prediction-from-multiple-models.html">Ensemble prediction from multiple models</a></div>
<div class="next"><a href="technical-annex.html">Technical Annex</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#object-based-time-series-image-analysis">Object-based time series image analysis</a></li>
<li><a class="nav-link" href="#generic-image-segmentation-in-sits">Generic Image segmentation in SITS</a></li>
<li><a class="nav-link" href="#simple-linear-iterative-clustering-slic-algorithm">Simple Linear Iterative Clustering (SLIC) algorithm</a></li>
<li><a class="nav-link" href="#example-of-slic-based-segmentation-and-classification">Example of SLIC-based segmentation and classification</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong><strong>sits</strong>: Satellite Image Time Series Analysis on Earth Observation Data Cubes</strong>" was written by Gilberto Camara, Rolf Simoes, Felipe Souza, Charlotte Pelletier, Alber Sanchez, Pedro R. Andrade, Karine Ferreira, Gilberto Queiroz. It was last built on 2023-06-21.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
